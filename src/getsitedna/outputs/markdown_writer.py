"""Markdown documentation generator for analysis results."""

from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Any
from urllib.parse import urlparse

from ..models.site import Site
from ..models.page import Page
from ..models.schemas import ComponentType


class MarkdownWriter:
    """Generate human-readable Markdown documentation from analysis results."""
    
    def __init__(self, output_directory: Path):
        self.output_directory = Path(output_directory)
        self.output_directory.mkdir(parents=True, exist_ok=True)
    
    def write_documentation(self, site: Site) -> Dict[str, Path]:
        """Write complete Markdown documentation for the site analysis."""
        output_files = {}
        
        # Main README
        readme_file = self.output_directory / "README.md"
        self._write_main_readme(site, readme_file)
        output_files["readme"] = readme_file
        
        # Technical specification
        spec_file = self.output_directory / "TECHNICAL_SPECIFICATION.md"
        self._write_technical_specification(site, spec_file)
        output_files["technical_spec"] = spec_file
        
        # Component library
        components_file = self.output_directory / "COMPONENT_LIBRARY.md"
        self._write_component_library(site, components_file)
        output_files["components"] = components_file
        
        # Design system
        design_file = self.output_directory / "DESIGN_SYSTEM.md"
        self._write_design_system(site, design_file)
        output_files["design_system"] = design_file
        
        # Implementation guide
        impl_file = self.output_directory / "IMPLEMENTATION_GUIDE.md"
        self._write_implementation_guide(site, impl_file)
        output_files["implementation"] = impl_file
        
        # Page-by-page analysis
        pages_dir = self.output_directory / "pages"
        pages_dir.mkdir(exist_ok=True)
        
        for page in site.crawled_pages[:10]:  # Limit to top 10 pages
            page_file = self._write_page_analysis(page, pages_dir)
            if page_file:
                page_key = f"page_{self._sanitize_filename(page.path or 'index')}"
                output_files[page_key] = page_file
        
        return output_files
    
    def _write_main_readme(self, site: Site, output_file: Path):
        """Write the main README file."""
        content = f"""# Website Analysis Report

## Site Overview

**URL:** {site.base_url}  
**Domain:** {site.domain}  
**Analysis Date:** {site.metadata.analysis_date.strftime('%Y-%m-%d %H:%M')}  
**Analysis Philosophy:** {site.metadata.analysis_philosophy.value.replace('_', ' ').title()}  
**Target Framework:** {site.metadata.target_framework.value.replace('_', ' ').title()}  

## Executive Summary

This analysis was conducted using GetSiteDNA v{site.metadata.tool_version} to understand the structure, design, and technical implementation of {site.domain}. The analysis provides comprehensive specifications for rebuilding or modernizing the website using {site.metadata.target_framework.value.replace('_', ' ').title()}.

### Key Findings

- **Pages Analyzed:** {site.stats.total_pages_analyzed}
- **Components Identified:** {len(site.component_specifications)}
- **Design Patterns:** {len(site.experience_patterns)}
- **Color Palette:** {len(site.global_color_palette)} primary colors
- **Typography:** {len(site.global_typography)} font families

## Design Intent

{self._format_design_intent(site)}

## Site Architecture

### Page Structure
```
{self._generate_site_map(site)}
```

### Key Components
{self._format_component_summary(site)}

## Quick Start

1. **Review the [Technical Specification](TECHNICAL_SPECIFICATION.md)** for detailed implementation requirements
2. **Explore the [Component Library](COMPONENT_LIBRARY.md)** for reusable UI components
3. **Check the [Design System](DESIGN_SYSTEM.md)** for colors, typography, and visual guidelines
4. **Follow the [Implementation Guide](IMPLEMENTATION_GUIDE.md)** for step-by-step development

## Files in this Analysis

| File | Description |
|------|-------------|
| `README.md` | This overview document |
| `TECHNICAL_SPECIFICATION.md` | Detailed technical requirements |
| `COMPONENT_LIBRARY.md` | UI component specifications |
| `DESIGN_SYSTEM.md` | Visual design guidelines |
| `IMPLEMENTATION_GUIDE.md` | Development roadmap |
| `specification.json` | Machine-readable specification |
| `pages/` | Individual page analysis |

## Analysis Quality

**Completeness Score:** {site.validation.completeness_score:.1%}

{self._format_validation_summary(site)}

---

*Generated by GetSiteDNA v{site.metadata.tool_version} on {datetime.now().strftime('%Y-%m-%d %H:%M')}*
"""
        self._write_file(output_file, content)
    
    def _write_technical_specification(self, site: Site, output_file: Path):
        """Write detailed technical specification."""
        content = f"""# Technical Specification

## Overview

This document provides comprehensive technical specifications for implementing {site.domain} using modern web technologies with a focus on {site.metadata.target_framework.value.replace('_', ' ').title()}.

## Technology Stack

### Recommended Stack
- **Framework:** {site.metadata.target_framework.value.replace('_', ' ').title()}
- **Accessibility:** {site.metadata.accessibility_level.value.upper()} compliance
- **Performance:** {', '.join(site.metadata.performance_targets)}

### Detected Technologies
{self._format_detected_technologies(site)}

## Performance Requirements

{self._format_performance_requirements(site)}

## Accessibility Requirements

- **Compliance Level:** {site.metadata.accessibility_level.value.upper()}
- **Keyboard Navigation:** Full keyboard accessibility required
- **Screen Reader Support:** Proper ARIA labels and semantic markup
- **Color Contrast:** Minimum 4.5:1 for normal text, 3:1 for large text

## Security Considerations

{self._format_security_considerations(site)}

## SEO Requirements

{self._format_seo_requirements(site)}

## Browser Support

- **Modern Browsers:** Chrome 90+, Firefox 88+, Safari 14+, Edge 90+
- **Mobile Support:** iOS Safari 14+, Chrome Mobile 90+
- **Progressive Enhancement:** Graceful degradation for older browsers

## API Integration

{self._format_api_requirements(site)}

## Content Management

{self._format_content_requirements(site)}

## Deployment Requirements

- **Hosting:** Static hosting with CDN support
- **Build Process:** Automated CI/CD pipeline
- **Environment Variables:** Secure configuration management
- **Monitoring:** Performance and error tracking

---

*This specification was automatically generated from the analysis of {site.base_url}*
"""
        self._write_file(output_file, content)
    
    def _write_component_library(self, site: Site, output_file: Path):
        """Write component library documentation."""
        content = f"""# Component Library

This document outlines all the UI components identified during the analysis of {site.domain}.

## Component Overview

{site.stats.total_components_identified} components were identified across {site.stats.total_pages_analyzed} pages.

"""
        
        # Group components by type
        components_by_type = {}
        for component in site.component_specifications:
            comp_type = component.component_type
            if comp_type not in components_by_type:
                components_by_type[comp_type] = []
            components_by_type[comp_type].append(component)
        
        # If no component specifications but components were identified, add a note
        if not site.component_specifications and site.stats.total_components_identified > 0:
            content += f"""
**Note:** {site.stats.total_components_identified} components were identified during page analysis. Detailed component specifications can be found in the individual page analysis files in the `pages/` directory.

"""
        
        # Write each component type
        for comp_type, components in components_by_type.items():
            content += f"## {comp_type.value.replace('_', ' ').title()} Components\n\n"
            
            for component in components:
                content += f"### {component.component_name}\n\n"
                content += f"**Purpose:** {component.design_intent}\n\n"
                
                if component.modern_features:
                    content += "**Modern Features:**\n"
                    for feature, description in component.modern_features.items():
                        content += f"- **{feature.replace('_', ' ').title()}:** {description}\n"
                    content += "\n"
                
                if component.accessibility_features:
                    content += "**Accessibility Features:**\n"
                    for feature in component.accessibility_features:
                        content += f"- {feature}\n"
                    content += "\n"
                
                if component.performance_considerations:
                    content += "**Performance Considerations:**\n"
                    for consideration in component.performance_considerations:
                        content += f"- {consideration}\n"
                    content += "\n"
                
                content += "---\n\n"
        
        content += f"""
## Implementation Notes

### Component Architecture
- **Modularity:** Each component should be self-contained and reusable
- **Props Interface:** Clear, typed props for all configurable options
- **State Management:** Local state for component-specific data
- **Styling:** CSS modules or styled-components for isolation

### Testing Strategy
- **Unit Tests:** Test component logic and prop handling
- **Integration Tests:** Test component interactions
- **Accessibility Tests:** Automated a11y testing
- **Visual Regression:** Screenshot comparison testing

### Documentation
- **Storybook:** Interactive component documentation
- **Code Examples:** Usage examples for each variant
- **Design Tokens:** Connection to design system values
"""
        
        self._write_file(output_file, content)
    
    def _write_design_system(self, site: Site, output_file: Path):
        """Write design system documentation."""
        content = f"""# Design System

Visual design guidelines and tokens for {site.domain}.

## Color Palette

### Primary Colors
"""
        
        # Colors
        for i, color in enumerate(site.global_color_palette[:8]):
            content += f"- **Color {i+1}:** `{color.hex}` (RGB: {color.rgb[0]}, {color.rgb[1]}, {color.rgb[2]})\n"
            if color.usage_context:
                content += f"  - Used in: {', '.join(color.usage_context[:3])}\n"
        
        content += "\n## Typography\n\n"
        
        # Typography
        for font in site.global_typography:
            content += f"### {font.family}\n"
            if font.weights:
                content += f"**Weights:** {', '.join(map(str, sorted(font.weights)))}\n"
            if font.sizes:
                content += f"**Sizes:** {', '.join(font.sizes[:5])}\n"
            if font.usage_context:
                content += f"**Usage:** {', '.join(font.usage_context)}\n"
            content += "\n"
        
        # Design tokens
        if site.global_design_tokens:
            content += "## Design Tokens\n\n"
            
            # Group tokens by category
            tokens_by_category = {}
            for token in site.global_design_tokens:
                category = token.category
                if category not in tokens_by_category:
                    tokens_by_category[category] = []
                tokens_by_category[category].append(token)
            
            for category, tokens in tokens_by_category.items():
                content += f"### {category.title()}\n\n"
                for token in tokens:
                    content += f"- `{token.name}`: {token.value}\n"
                content += "\n"
        
        content += """
## Spacing System

### Grid System
- **Container:** Max-width with centered content
- **Columns:** 12-column responsive grid
- **Gutters:** Consistent spacing between columns

### Spacing Scale
- **Base unit:** 4px or 8px
- **Scale:** 0.25x, 0.5x, 1x, 1.5x, 2x, 3x, 4x, 6x, 8x

## Responsive Breakpoints

- **Mobile:** 0-767px
- **Tablet:** 768-1023px
- **Desktop:** 1024-1199px
- **Large Desktop:** 1200px+

## Component States

### Interactive States
- **Default:** Normal resting state
- **Hover:** Mouse over interaction
- **Focus:** Keyboard focus state
- **Active:** Currently pressed/selected
- **Disabled:** Non-interactive state

### Feedback States
- **Success:** Positive confirmation
- **Warning:** Cautionary information
- **Error:** Problem or failure
- **Info:** Neutral information

## Accessibility Guidelines

- **Color Contrast:** 4.5:1 minimum for normal text
- **Focus Indicators:** Visible focus states for all interactive elements
- **Touch Targets:** Minimum 44px for mobile interactions
- **Motion:** Respect prefers-reduced-motion preferences
"""
        
        self._write_file(output_file, content)
    
    def _write_implementation_guide(self, site: Site, output_file: Path):
        """Write step-by-step implementation guide."""
        framework = site.metadata.target_framework.value.replace('_', ' ').title()
        
        content = f"""# Implementation Guide

Step-by-step guide for implementing {site.domain} using {framework}.

## Phase 1: Project Setup

### 1. Initialize Project
```bash
# For React + Next.js
npx create-next-app@latest {site.domain.replace('.', '-')} --typescript --tailwind --eslint

# For Vue + Nuxt
npx nuxi@latest init {site.domain.replace('.', '-')}

# For Svelte + SvelteKit
npm create svelte@latest {site.domain.replace('.', '-')}
```

### 2. Install Dependencies
```bash
# Core dependencies
npm install @headlessui/react @heroicons/react  # For React
npm install @headlessui/vue @heroicons/vue     # For Vue
npm install @tailwindcss/forms @tailwindcss/typography

# Development dependencies
npm install -D @types/node eslint-config-prettier prettier
```

### 3. Configure Build Tools
- Set up TypeScript configuration
- Configure ESLint and Prettier
- Set up Tailwind CSS with design tokens
- Configure image optimization

## Phase 2: Design System Implementation

### 1. Set Up Design Tokens
Create a tokens configuration file with:
- Color palette from analysis
- Typography scale
- Spacing system
- Component variants

### 2. Implement Base Styles
- Global CSS reset
- Typography styles
- Color utilities
- Spacing utilities

### 3. Create Foundation Components
{self._format_foundation_components(site)}

## Phase 3: Component Development

### Priority Order
{self._format_component_priorities(site)}

### Implementation Checklist
For each component:
- [ ] Create base component structure
- [ ] Implement responsive design
- [ ] Add accessibility features
- [ ] Write unit tests
- [ ] Document in Storybook
- [ ] Optimize performance

## Phase 4: Page Assembly

### 1. Create Layout Components
- Header layout
- Footer layout
- Main content wrapper
- Sidebar layout (if applicable)

### 2. Implement Pages
{self._format_page_implementation_order(site)}

### 3. Connect Dynamic Content
- Set up API integration
- Implement data fetching
- Add loading states
- Handle error states

## Phase 5: Performance Optimization

### 1. Core Web Vitals
- Optimize Largest Contentful Paint (LCP)
- Minimize First Input Delay (FID)
- Reduce Cumulative Layout Shift (CLS)

### 2. Asset Optimization
- Implement image optimization
- Set up code splitting
- Optimize font loading
- Minimize JavaScript bundles

### 3. Caching Strategy
- Set up static file caching
- Implement API response caching
- Configure service worker (if needed)

## Phase 6: Accessibility & Testing

### 1. Accessibility Audit
- Run automated accessibility tests
- Perform manual keyboard testing
- Test with screen readers
- Validate color contrast

### 2. Cross-Browser Testing
- Test on target browsers
- Validate responsive design
- Check performance on mobile devices

### 3. Quality Assurance
- End-to-end testing
- Performance testing
- Security scanning
- SEO validation

## Phase 7: Deployment

### 1. Production Build
- Optimize bundle size
- Configure environment variables
- Set up error tracking
- Enable analytics

### 2. Deploy to Production
- Set up CI/CD pipeline
- Configure hosting platform
- Set up domain and SSL
- Monitor deployment

### 3. Post-Launch
- Monitor performance metrics
- Set up error alerting
- Plan content migration
- Schedule regular audits

## Estimated Timeline

- **Phase 1-2:** 1-2 weeks (Setup & Design System)
- **Phase 3:** 3-6 weeks (Component Development)
- **Phase 4:** 2-4 weeks (Page Assembly)
- **Phase 5:** 1-2 weeks (Performance)
- **Phase 6:** 1-2 weeks (Testing)
- **Phase 7:** 1 week (Deployment)

**Total Estimated Time:** 9-17 weeks

*Timeline may vary based on project complexity and team size.*
"""
        
        self._write_file(output_file, content)
    
    def _write_page_analysis(self, page: Page, pages_dir: Path) -> Optional[Path]:
        """Write individual page analysis."""
        if not page.is_successful:
            return None
        
        filename = self._sanitize_filename(page.path or 'index') + '.md'
        output_file = pages_dir / filename
        
        content = f"""# Page Analysis: {page.title or page.url}

**URL:** {page.url}  
**Title:** {page.title or 'No title'}  
**Analysis Date:** {page.analyzed_at.strftime('%Y-%m-%d %H:%M') if page.analyzed_at else 'Not analyzed'}

## Content Analysis

### SEO Metadata
- **Title:** {page.seo.title or 'Not set'}
- **Description:** {page.seo.description or 'Not set'}
- **Keywords:** {', '.join(page.seo.keywords) if page.seo.keywords else 'None'}

### Content Structure
{self._format_page_content_structure(page)}

## Components Found

{self._format_page_components(page)}

## Design Elements

### Colors Used
{self._format_page_colors(page)}

### Typography
{self._format_page_typography(page)}

## Technical Details

### Performance Metrics
{self._format_page_performance(page)}

### Assets
- **Total Assets:** {len(page.assets)}
- **Images:** {len([a for a in page.assets if a.type == 'image'])}
- **Stylesheets:** {len([a for a in page.assets if a.type == 'css'])}
- **Scripts:** {len([a for a in page.assets if a.type == 'javascript'])}

### Links
- **Internal Links:** {len(page.internal_links)}
- **External Links:** {len(page.external_links)}

## Implementation Notes

{self._format_page_implementation_notes(page)}

---

*Page analysis generated from {page.url}*
"""
        
        self._write_file(output_file, content)
        return output_file
    
    def _format_design_intent(self, site: Site) -> str:
        """Format design intent section."""
        if not any([site.design_intent.brand_personality, 
                   site.design_intent.user_experience_goals]):
            return "Design intent analysis is in progress."
        
        content = ""
        if site.design_intent.brand_personality:
            content += f"**Brand Personality:** {', '.join(site.design_intent.brand_personality)}\n\n"
        
        if site.design_intent.user_experience_goals:
            content += f"**UX Goals:** {', '.join(site.design_intent.user_experience_goals)}\n\n"
        
        if site.design_intent.conversion_focus:
            content += f"**Conversion Focus:** {site.design_intent.conversion_focus}\n\n"
        
        return content
    
    def _generate_site_map(self, site: Site) -> str:
        """Generate a simple text sitemap."""
        sitemap = f"{site.domain}/\n"
        
        # Group pages by depth
        pages_by_depth = {}
        for page in site.crawled_pages:
            depth = page.depth
            if depth not in pages_by_depth:
                pages_by_depth[depth] = []
            pages_by_depth[depth].append(page)
        
        for depth in sorted(pages_by_depth.keys()):
            pages = pages_by_depth[depth][:5]  # Limit to 5 pages per depth
            indent = "  " * (depth + 1)
            for page in pages:
                path = page.path or '/'
                sitemap += f"{indent}├── {path}\n"
        
        return sitemap
    
    def _format_component_summary(self, site: Site) -> str:
        """Format component summary."""
        if not site.component_specifications:
            return "No components identified."
        
        component_counts = {}
        for component in site.component_specifications:
            comp_type = component.component_type.value
            component_counts[comp_type] = component_counts.get(comp_type, 0) + 1
        
        summary = ""
        for comp_type, count in sorted(component_counts.items()):
            summary += f"- **{comp_type.replace('_', ' ').title()}:** {count} components\n"
        
        return summary
    
    def _format_validation_summary(self, site: Site) -> str:
        """Format validation summary."""
        content = ""
        
        if site.validation.quality_metrics:
            content += "### Quality Metrics\n"
            for metric, value in site.validation.quality_metrics.items():
                content += f"- **{metric.replace('_', ' ').title()}:** {value}\n"
            content += "\n"
        
        if site.validation.recommendations:
            content += "### Recommendations\n"
            for rec in site.validation.recommendations[:5]:
                content += f"- {rec}\n"
            content += "\n"
        
        return content
    
    def _sanitize_filename(self, filename: str) -> str:
        """Sanitize filename for safe filesystem usage."""
        import re
        # Replace invalid characters
        filename = re.sub(r'[<>:"/\\|?*]', '_', filename)
        # Remove multiple underscores
        filename = re.sub(r'_+', '_', filename)
        # Trim and remove leading/trailing underscores
        filename = filename.strip('_')
        # Ensure not empty
        if not filename:
            filename = 'page'
        return filename
    
    def _write_file(self, file_path: Path, content: str):
        """Write content to file."""
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(content)
    
    # Helper methods for formatting various sections
    def _format_detected_technologies(self, site: Site) -> str:
        all_frameworks = set()
        for page in site.crawled_pages:
            all_frameworks.update(page.technical.javascript_frameworks)
        
        if all_frameworks:
            return "- " + "\n- ".join(sorted(all_frameworks))
        return "- No specific frameworks detected"
    
    def _format_performance_requirements(self, site: Site) -> str:
        return f"""### Core Web Vitals Targets
- **LCP (Largest Contentful Paint):** < 2.5 seconds
- **FID (First Input Delay):** < 100 milliseconds
- **CLS (Cumulative Layout Shift):** < 0.1

### Performance Budget
- **JavaScript Bundle:** < 250KB gzipped
- **CSS Bundle:** < 50KB gzipped
- **Images:** WebP format with responsive sizing
- **Fonts:** Preload critical fonts, subsetting for performance"""
    
    def _format_security_considerations(self, site: Site) -> str:
        return f"""- **Content Security Policy:** Implement strict CSP headers
- **HTTPS Only:** Enforce HTTPS for all connections
- **Input Validation:** Sanitize all user inputs
- **Authentication:** Secure session management
- **Data Protection:** Follow GDPR/privacy regulations"""
    
    def _format_seo_requirements(self, site: Site) -> str:
        return f"""- **Meta Tags:** Complete title, description, and OG tags for all pages
- **Structured Data:** Implement relevant schema markup
- **Sitemap:** Generate dynamic XML sitemap
- **Robots.txt:** Configure crawling permissions
- **Page Speed:** Optimize for Core Web Vitals
- **Mobile-First:** Responsive design with mobile optimization"""
    
    def _format_api_requirements(self, site: Site) -> str:
        api_endpoints = set()
        for page in site.crawled_pages:
            api_endpoints.update(page.technical.api_endpoints)
        
        if api_endpoints:
            return f"Detected API endpoints:\n- " + "\n- ".join(list(api_endpoints)[:10])
        return "No API endpoints detected in the analysis."
    
    def _format_content_requirements(self, site: Site) -> str:
        # Flatten and count unique content categories
        all_categories = set()
        for page in site.crawled_pages:
            categories = page.content.content_structure.get('categories', [])
            if categories and isinstance(categories, list):
                all_categories.update(categories)
        
        return f"""- **CMS Integration:** Consider headless CMS for content management
- **Content Types:** {len(all_categories)} content categories identified
- **Media Management:** Centralized asset management system
- **SEO Management:** Built-in SEO optimization tools"""
    
    def _format_foundation_components(self, site: Site) -> str:
        foundation = [
            "Button variants (primary, secondary, outline)",
            "Form controls (input, textarea, select)",
            "Typography components (headings, body text)",
            "Layout containers (grid, flexbox utilities)",
            "Navigation elements (links, breadcrumbs)"
        ]
        return "1. " + "\n2. ".join(foundation)
    
    def _format_component_priorities(self, site: Site) -> str:
        if not site.component_specifications:
            return "No specific components identified for prioritization."
        
        # Sort by component type importance
        priority_order = [
            ComponentType.HEADER, ComponentType.NAVIGATION, ComponentType.FOOTER,
            ComponentType.HERO, ComponentType.CARD, ComponentType.BUTTON,
            ComponentType.FORM, ComponentType.MODAL, ComponentType.CAROUSEL
        ]
        
        prioritized = []
        for comp_type in priority_order:
            components = [c for c in site.component_specifications if c.component_type == comp_type]
            if components:
                prioritized.append(f"**{comp_type.value.replace('_', ' ').title()}:** {len(components)} components")
        
        return "\n".join(f"{i+1}. {comp}" for i, comp in enumerate(prioritized))
    
    def _format_page_implementation_order(self, site: Site) -> str:
        pages = sorted(site.crawled_pages, key=lambda p: p.depth)[:10]
        order = []
        for i, page in enumerate(pages, 1):
            path = page.path or '/'
            title = page.title or 'Untitled Page'
            order.append(f"{i}. **{path}** - {title}")
        
        return "\n".join(order)
    
    def _format_page_content_structure(self, page: Page) -> str:
        if not page.content.text_content:
            return "No content structure analysis available."
        
        structure = ""
        for content_type, content_list in page.content.text_content.items():
            if content_list:
                structure += f"- **{content_type.value.replace('_', ' ').title()}:** {len(content_list)} items\n"
        
        return structure or "Content structure analysis pending."
    
    def _format_page_components(self, page: Page) -> str:
        if not page.structure.components:
            return "No components identified on this page."
        
        components = ""
        for component in page.structure.components:
            components += f"### {component.component_name}\n"
            components += f"**Type:** {component.component_type.value.replace('_', ' ').title()}\n"
            components += f"**Purpose:** {component.design_intent}\n\n"
        
        return components
    
    def _format_page_colors(self, page: Page) -> str:
        if not page.design.color_palette:
            return "No colors extracted from this page."
        
        colors = ""
        for color in page.design.color_palette[:5]:
            colors += f"- `{color.hex}` (used {color.frequency} times)\n"
        
        return colors
    
    def _format_page_typography(self, page: Page) -> str:
        if not page.design.typography:
            return "No typography information available."
        
        fonts = ""
        for font in page.design.typography:
            fonts += f"- **{font.family}**"
            if font.weights:
                fonts += f" (weights: {', '.join(map(str, font.weights))})"
            fonts += "\n"
        
        return fonts
    
    def _format_page_performance(self, page: Page) -> str:
        metrics = page.technical.performance_metrics
        if not metrics:
            return "No performance metrics available."
        
        perf = ""
        for metric, value in metrics.items():
            if isinstance(value, (int, float)):
                if 'time' in metric.lower():
                    perf += f"- **{metric.replace('_', ' ').title()}:** {value}ms\n"
                else:
                    perf += f"- **{metric.replace('_', ' ').title()}:** {value}\n"
        
        return perf
    
    def _format_page_implementation_notes(self, page: Page) -> str:
        notes = []
        
        if page.structure.layout_type:
            notes.append(f"- Layout type: {page.structure.layout_type.replace('_', ' ').title()}")
        
        if page.technical.forms:
            notes.append(f"- Contains {len(page.technical.forms)} form(s)")
        
        if page.technical.javascript_frameworks:
            notes.append(f"- Uses: {', '.join(page.technical.javascript_frameworks)}")
        
        if not notes:
            notes.append("- Standard page implementation")
        
        return "\n".join(notes)